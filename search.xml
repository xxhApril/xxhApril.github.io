<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《iOS面试之道》两篇总结之一：开发技能篇</title>
    <url>/2022/09/07/%E3%80%8AiOS%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%8B%E4%B8%A4%E7%AF%87%E6%80%BB%E7%BB%93%E4%B9%8B%E4%B8%80%EF%BC%9A%E4%B8%93%E4%B8%9A%E9%97%AE%E7%AD%94%E7%AF%87/</url>
    <content><![CDATA[<p>《iOS 面试之道》是故胤道长和唐巧 2018 年合著的针对面试一些问题的书，买之后虽有翻阅，但是始终未认真通读。现在想把书中对于我来说有价值的知识点，简短的总结一下。这里分两篇来说，算法基础放到下篇吧。</p>
<span id="more"></span>
<p><a href="">《iOS 面试之道》两篇总结之一：开发技能篇</a></p>
<p><a href="">《iOS 面试之道》两篇总结之二：算法基础篇</a></p>
<h2 id="语言工具"><a class="markdownIt-Anchor" href="#语言工具">#</a> 语言工具</h2>
<h3 id="swfit"><a class="markdownIt-Anchor" href="#swfit">#</a> Swfit</h3>
<h4 id="swift-面试理论题"><a class="markdownIt-Anchor" href="#swift-面试理论题">#</a> Swift 面试理论题</h4>
<h5 id="类class和结构体struct有什么区别"><a class="markdownIt-Anchor" href="#类class和结构体struct有什么区别">#</a> 类（Class）和结构体（struct）有什么区别</h5>
<p>在 Swift 中，class 是引用类型，struct 是值类型。值类型在传递和赋值时进行复制，引用类型则只会引用对象的一个 “指向”。其实，两个的区别，也是 class、struct 两种类型的区别。</p>
<p>在内存中，引用类型，诸如类，是在堆（Heap）上进行存储和操作的；而值类型，诸如结构体，是在栈上进行存储和操作的。相比栈上操作，堆上操作更加耗时和复杂，所以，苹果公司也推荐使用结构体，可以提高 App 的运行效率。</p>
<p>class 的如下功能是 struct 没有的：</p>
<ul>
<li>可以继承，这样子类可用父类的特性和方法。</li>
<li>类型转化可以在运行时检查和解释一个实例的类型。</li>
<li>可以用 deinit 来释放资源。</li>
<li>一个类可以被多次引用。</li>
</ul>
<p>struct 也有如下优势：</p>
<ul>
<li>结构较小，适用于复制操作，相比一个 class 被多次引用，struct 更加安全。</li>
<li>无需担心内存泄漏或者多线程冲突问题。</li>
</ul>
<h5 id="swift-是面向对象还是函数式编程语言"><a class="markdownIt-Anchor" href="#swift-是面向对象还是函数式编程语言">#</a> Swift 是面向对象还是函数式编程语言</h5>
<p>Swift 即是面向对象的编程语言，也是函数式的编程语言。</p>
<p>说 Swift 是面向对象的语言，因为 Swift 支持类的封装、继承和多态，从这点来说，Swift 和 Java 这类纯面向对象的编程语言几乎毫无差别。</p>
<p>说 Swift 是函数式的编程语言，是因为 Swift 支持 map、reduce、filter、flatmap 这类去除中间状态、数学函数式的方法，更加强调运算结果而不是中间过程。</p>
<h5 id="在-swift-中什么是可选型"><a class="markdownIt-Anchor" href="#在-swift-中什么是可选型">#</a> 在 Swift 中，什么是可选型</h5>
<p>在 Swift 中，可选型是为了表达一个变量值为空的情况。无论变量时值类型，还是引用类型，都可以是可选变量。</p>
<p>在 Objective-C 中没有明确提出可选型的概念，而引用类型可以为 nil，来标识其变量值为空的情况。值类型并不可以。</p>
<h5 id="在-swift-中什么是泛型generics"><a class="markdownIt-Anchor" href="#在-swift-中什么是泛型generics">#</a> 在 Swift 中，什么是泛型（Generics）</h5>
<p>在 Swift 中，泛型是为增加代码的灵活性而生的：它可以使对应的代码满足任意类型的变量或方法。</p>
<h5 id="说明并比较关键词openpublicinternalfileprivate-和-private"><a class="markdownIt-Anchor" href="#说明并比较关键词openpublicinternalfileprivate-和-private">#</a> 说明并比较关键词：open,public,internal,fileprivate 和 private</h5>
<p>访问级别从高到低依次为：open &gt; public &gt; internal &gt; fileprivate &gt; private。</p>
<p>它们遵循的基本原则是：高级别的变量不允许被定义为低级别变量的成员变量，反之可以。</p>
<p>public 与 open 的唯一区别在于：它修饰的对象可以在任意 Module 中被访问，但不能重写。</p>
<h5 id="说明并比较关键词strong-weak-和-unowned"><a class="markdownIt-Anchor" href="#说明并比较关键词strong-weak-和-unowned">#</a> 说明并比较关键词：strong, weak 和 unowned</h5>
<p>Swift 的管理机制与 OC 一样都是 ARC。</p>
<p>unowned 与 weak 本质是一样的，唯一不同的是：对象被释放后，仍然有一个无效的引用指向对象。它不是 Optional，也不指向 nil。如果继续访问，则会引起崩溃。</p>
<p>weak 与 unowned 都可以用来解决循环引用。但是更推荐使用 weak，防止意外引发崩溃。</p>
<h5 id="在-swift-中如何理解-copy-on-write"><a class="markdownIt-Anchor" href="#在-swift-中如何理解-copy-on-write">#</a> 在 Swift 中，如何理解 copy-on-write</h5>
<p>当值类型在复制时，复制的对象和原对象实质上在内存中指向同一个对象。当且仅当修改复制的对象时，才会在内存中创建一个新的对象。因此可使得值类型被多次复制而无需耗费太多的内存，只有变化时才会增加开销，使内存的使用更加高效。</p>
<p>另外，可通过下面方式简单查看对象内存地址：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrA <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;arrA 地址：&quot;</span>, <span class="type">String</span>(format: <span class="string">&quot;%p&quot;</span>, arrA));</span><br></pre></td></tr></table></figure>
<p>值类型每次操作后，如赋值、修改等，其内存地址都会改变。</p>
<h5 id="什么是属性观察property-observer"><a class="markdownIt-Anchor" href="#什么是属性观察property-observer">#</a> 什么是属性观察（Property Observer）</h5>
<p>在 Swift 中，属性观察器，即 didSet 和 willSet。</p>
<p>初始化方法的设定、以及在 willSet、didSet 中对属性的再次设定、属性销毁时，都不会触发调用属性观察。</p>
<h4 id="swift-面试实战题"><a class="markdownIt-Anchor" href="#swift-面试实战题">#</a> Swift 面试实战题</h4>
<h5 id="在结构体中如何修改成员变量"><a class="markdownIt-Anchor" href="#在结构体中如何修改成员变量">#</a> 在结构体中如何修改成员变量</h5>
<p>使用 mutating 关键字。</p>
<p>另外，如果设计协议时，协议需要被值类型实现，则需要考虑是否给协议方法或者属性添加关键字 mutating。</p>
<h5 id="在-swift-中如何实现或操作"><a class="markdownIt-Anchor" href="#在-swift-中如何实现或操作">#</a> 在 Swift 中如何实现或（||）操作</h5>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">||</span>(<span class="params">left</span>: <span class="type">Bool</span>, <span class="params">right</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> left &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有左侧为假时，才计算右侧，防止不必要的计算开销。</p>
<h5 id="实现一个函数输入任意一个整数输出为输入的整数2"><a class="markdownIt-Anchor" href="#实现一个函数输入任意一个整数输出为输入的整数2">#</a> 实现一个函数：输入任意一个整数，输出为输入的整数 + 2</h5>
<p>这个函数主要考察柯里化。Swift 的柯里化特性是函数式编程思想的体现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">add</span>(<span class="keyword">_</span> <span class="params">num</span>: <span class="type">Int</span>) -&gt;(<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; val <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> num <span class="operator">+</span> val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="实现一个函数求-0-~-100包括-0-和-100中为偶数并且恰好是其他数字平方的数字"><a class="markdownIt-Anchor" href="#实现一个函数求-0-~-100包括-0-和-100中为偶数并且恰好是其他数字平方的数字">#</a> 实现一个函数：求 0 ~ 100（包括 0 和 100）中为偶数并且恰好是其他数字平方的数字</h5>
<p>考察函数式编程思想。如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr <span class="operator">=</span> (<span class="number">0</span> <span class="operator">...</span> <span class="number">10</span>).map &#123; <span class="variable">$0</span> <span class="operator">*</span> <span class="variable">$0</span> &#125;.filter &#123; <span class="variable">$0</span> <span class="operator">%</span> <span class="number">2</span> <span class="operator">==</span> <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="objective-c"><a class="markdownIt-Anchor" href="#objective-c">#</a> Objective-C</h3>
<h4 id="objective-c-面试理论题"><a class="markdownIt-Anchor" href="#objective-c-面试理论题">#</a> Objective-C 面试理论题</h4>
<h5 id="什么是-arc"><a class="markdownIt-Anchor" href="#什么是-arc">#</a> 什么是 ARC</h5>
<p>自动引用计数，更多详细信息可看：<a href="http://xxhsu.com/2019/11/29/%E3%80%8AObjective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E4%B8%89%E7%AF%87%E6%80%BB%E7%BB%93%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AF%87/">《Objective-C 高级编程》三篇总结之一：引用计数篇</a></p>
<h5 id="什么情况下会出现循环引用"><a class="markdownIt-Anchor" href="#什么情况下会出现循环引用">#</a> 什么情况下会出现循环引用</h5>
<p>多个对象相互强引用，导致无法释放，造成内存泄漏。</p>
<p>可使用 weak 或者 __block 来解决循环引用。</p>
<p>Xcode 中的 Debug Memory Graph 可检查内存泄漏。</p>
<h5 id="说明并比较关键字strong-weak-assign-和-copy"><a class="markdownIt-Anchor" href="#说明并比较关键字strong-weak-assign-和-copy">#</a> 说明并比较关键字：strong, weak, assign 和 copy</h5>
<p>在上面那篇文章中有过详细说明。这里再补充几点：</p>
<ul>
<li>weak 一般用来修饰对象，assign 用来修饰基本数据类型。因为 assign 修饰的对象被释放后，指针地址依然存在，造成 “野指针”，在堆上容易造成崩溃。而栈上的内存系统会自动处理，不会造成 “野指针”。</li>
<li>在 Objective-C 中，基本数据类型的默认关键字是 atomic、readwrite 和 assign；普通属性的默认关键字是 atomic、readwrite 和 strong。</li>
</ul>
<h5 id="说明并比较关键字atomic-和-nonatomic"><a class="markdownIt-Anchor" href="#说明并比较关键字atomic-和-nonatomic">#</a> 说明并比较关键字：atomic 和 nonatomic</h5>
<ul>
<li>atomic 修饰的对象会保证 getter 和 setter 的完整性，任何线程访问它都可以得到一个完整的初始化对象，因为要保证操作完成，所以速度比较慢。atomic 比 nonatomic 安全，但也不是绝对的线程安全，例如多个线程同时调用 get 和 set 时，就会导致获得的对象值不一致。想要线程绝对安全，就要用 @synthesize。</li>
<li>nonatomic 修饰的对象不保证 getter 和 setter 的完整性，所以当多个线程访问它时，它可能返回未初始化的对象。正因为如此，nonatomic 比 atomic 速度快，但是线程也是不安全的。</li>
</ul>
<h5 id="说明并比较关键字property-synthesize-dynamic"><a class="markdownIt-Anchor" href="#说明并比较关键字property-synthesize-dynamic">#</a> 说明并比较关键字：@property, @synthesize, @dynamic</h5>
<p>参考： <a href="https://www.jianshu.com/p/0695ecbe9e06">iOS - @property 与 @synthesize 与 @dynamic</a></p>
<p>上面文章说的非常详细，这里我只做个简单总结。</p>
<p><strong>@property:</strong></p>
<ol>
<li>@property 是声明属性的语法。被 @property 声明的属性，系统已经自动生成了实例变量，即下划线变量。</li>
<li>如果对 @property 声明的属性单独重写了 setter 或者 getter 方法，都可以使用该属性的实例变量。一旦同时重写了 setter 和 getter 方法，再使用实例变量时就会报错，此时需要使用 @synthesize。如下： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> name = _name;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">if</span> (_name == <span class="literal">nil</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>@synthesize:</strong></p>
<ol>
<li>@synthesize 为属性添加一个实例变量名，或者说别名。同时会为该属性生成默认的 setter 和 getter 方法。</li>
<li>如果属性手动已经实现了自己的 setter 和 getter 方法，可以使用 @dynamic 来阻止 @synthesize 自动生成的 setter/getter 覆盖。</li>
<li>当在协议 Protocol 中声明属性时，协议中声明的属性不会自动生成 setter 和 getter，需要使用 @synthesize 生成 getter 和 setter。</li>
<li>@property 声明的属性有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize 和 @dynamic 都没写，默认是 @synthesize var = _var;</li>
<li>如果我们同时写了 getter 和 setter 方法，就需要在 .m 文件中使用 @synthesize。</li>
</ol>
<p><strong>@dynamic:</strong></p>
<ol>
<li>@dynamic 告诉编译器：该属性的 setter 和 getter 方法已由用户自己实现，不自动生成。</li>
<li>加入一个属性被 @dynamic 修饰，但是开发者并没有提供 setter 和 getter 方法，编译时候没有问题，一旦在运行过程中，访问到该属性、或者修改该属性时，都会因为缺少 setter 或者 getter 方法而引发崩溃。</li>
<li>编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</li>
</ol>
<h5 id="runloop-和线程有什么关系"><a class="markdownIt-Anchor" href="#runloop-和线程有什么关系">#</a> RunLoop 和线程有什么关系</h5>
<p>详细可参考：<a href="https://www.jianshu.com/p/a8fc0dd66cbb">Runloop 分析</a></p>
<p>RunLoop 是每一个线程一直运行的一个对象，它主要用来负责响应需要处理的各种事件和消息。每个线程都有且仅有一个 RunLoop 与其对应，没有线程，就没有 RunLoop。</p>
<p>在所有线程中，只有主线程的 RunLoop 是默认启动的，main 函数会设置一个 NSRunLoop 对象。而其他线程的 RunLoop 是默认没有启动的，可以通过  <code> [NSRunLoop currentRunLoop]</code>  来启动。</p>
<h5 id="说明并比较关键词__weak-和-__block"><a class="markdownIt-Anchor" href="#说明并比较关键词__weak-和-__block">#</a> 说明并比较关键词：__weak 和 __block</h5>
<p>详细可参考：<a href="https://www.jianshu.com/p/e42f86a81045">《Objective-C 高级编程》三篇总结之二：Block 篇</a></p>
<ul>
<li>__weak 与 weak 基本相同，前者修饰变量，后者修饰属性。__weak 主要用于防止 Block 中的循环引用。</li>
<li>__block 也用于修饰变量。它是引用修饰，所以其修饰的值是动态变化的，可以被重新赋值。</li>
</ul>
<h5 id="什么是block它和代理的区别是什么"><a class="markdownIt-Anchor" href="#什么是block它和代理的区别是什么">#</a> 什么是 Block？它和代理的区别是什么</h5>
<p>Block 是带有自动变量的匿名函数。详细可参考 <a href="https://www.jianshu.com/p/e42f86a81045">《Objective-C 高级编程》三篇总结之二：Block 篇</a>。</p>
<p>这里再简单总结下它们的主要区别：</p>
<p>Block 和代理的首要区别在于 Block 集中代码块，而代理分散代码块。所以 Block 更适合轻便、简单的回调。如网络传输。而代理适用公共接口较多的情况。这样做也更易于解耦代码结构。</p>
<p>两者的另一个区别在于，Block 运行成本高。Block 出栈时，需要将使用的数据从栈内存复制到堆内存，如果是对象，则引用计数 +1，使用完或者 Block 置为 nil 后才消除。delegate 只是保留了一个对象指针，直接回调，并没有额外消耗。并且 Block 更易造成循环引用。</p>
<h4 id="objective-c-面试实战题"><a class="markdownIt-Anchor" href="#objective-c-面试实战题">#</a> Objective-C 面试实战题</h4>
<h5 id="属性声明代码风格考查"><a class="markdownIt-Anchor" href="#属性声明代码风格考查">#</a> 属性声明代码风格考查</h5>
<p>具有 mutable 的对象应该用 copy 修饰，防止被动态修改。应该多用 NSInteger、CGFloat 等。</p>
<p>另外，如果可变类型如 NSMutableString 用 copy 修饰，那么对其修改时，程序会崩溃，报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[NSTaggedPointerString appendString:]: unrecognized selector sent to instance 0x824f62a252296794</span><br></pre></td></tr></table></figure>
<h5 id="架构解耦代码考查"><a class="markdownIt-Anchor" href="#架构解耦代码考查">#</a> 架构解耦代码考查</h5>
<p>OC 的 enum 应该带有 全名 + case 名，方便与 Swift 混编，如 SexBoy。</p>
<p>Model 应与 View 划清界限。</p>
<h5 id="内存管理语法考查"><a class="markdownIt-Anchor" href="#内存管理语法考查">#</a> 内存管理语法考查</h5>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *fir = <span class="string">@&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *sec = <span class="string">@&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;fir 内存地址：%p   sec 内存地址：%p&quot;</span>, fir,sec);</span><br><span class="line"><span class="keyword">if</span> (fir == sec) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;fir == sec&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;fir != sec&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([fir isEqualToString:sec]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;[fir isEqualToString:sec] == YES&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;[fir isEqualToString:sec] == NO&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-25</span> <span class="number">11</span>:<span class="number">46</span>:<span class="number">44.336661</span>+<span class="number">0800</span> GCD[<span class="number">58834</span>:<span class="number">2265032</span>] fir 内存地址：<span class="number">0x108ddc2c8</span>   sec 内存地址：<span class="number">0x108ddc2c8</span></span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-25</span> <span class="number">11</span>:<span class="number">46</span>:<span class="number">44.337619</span>+<span class="number">0800</span> GCD[<span class="number">58834</span>:<span class="number">2265032</span>] fir == sec</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-25</span> <span class="number">11</span>:<span class="number">46</span>:<span class="number">44.348583</span>+<span class="number">0800</span> GCD[<span class="number">58834</span>:<span class="number">2265032</span>] [fir isEqualToString:sec] == <span class="literal">YES</span></span><br></pre></td></tr></table></figure>
<p>内存地址相同。字符串存在数据区。</p>
<h5 id="多线程语法考查"><a class="markdownIt-Anchor" href="#多线程语法考查">#</a> 多线程语法考查</h5>
<p>视图刷新放到主线程。</p>
<blockquote>
<p>吐槽一下，这本书对于这些知识点说明的真的是简单到令人发指啊！！！</p>
</blockquote>
<h5 id="runloop-timer"><a class="markdownIt-Anchor" href="#runloop-timer">#</a> RunLoop Timer</h5>
<p>滑动时，ScrollView 视图上的 timer 停止，这里有两种方案解决：</p>
<ol>
<li>将 timer 加到 NSRunLoopCommonModes 中。</li>
<li>将 timer 放到另一个线程中，并开启另一个线程的 RunLoop。</li>
</ol>
<p>示例如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(repeat:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">true</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="swift-vs-objective-c"><a class="markdownIt-Anchor" href="#swift-vs-objective-c">#</a> Swift VS Objective-C</h3>
<p>Swift 是静态类型语言，Objective-C 是动态类型语言。</p>
<p>这小节从数据结构、编程思路和语言特性三点来作对比。</p>
<h5 id="swift-为什么将-string-array-和-dictionary-设计成值类型"><a class="markdownIt-Anchor" href="#swift-为什么将-string-array-和-dictionary-设计成值类型">#</a> Swift 为什么将 String、Array 和 Dictionary 设计成值类型</h5>
<p>首要要知道，在 OC 中，这三个都被设计成了引用类型。</p>
<ul>
<li>值类型相比引用类型，最大的优势就是可以高效的使用内存。值类型在栈上操作，引用类型通常在堆上操作。栈上的操作仅仅是单个指针的上下移动，而堆上的操作则牵涉到合并、移位、重新链接等。也就是说，Swift 这么设计大幅度减少了堆上的内存分配和回收的次数。同时，copy-on-write 又将值传递和复制到开销降到最低。</li>
<li>Swift 将它们设计成值类型也是为了线程安全。通过 Swift 的 let 设置，是得这些数据达到真正意义上的 “不变”，也从根本上解决了多线程众内存访问和操作顺序的问题。</li>
<li>Swift 将它们设计成值类型可以提高 API 的灵活度。譬如添加协议等，对数据进行操作等。</li>
</ul>
<h5 id="如何用-swift-将协议-protocol-中部分方法设计成可选-optional"><a class="markdownIt-Anchor" href="#如何用-swift-将协议-protocol-中部分方法设计成可选-optional">#</a> 如何用 Swift 将协议 Protocol 中部分方法设计成可选 optional</h5>
<p>一共有两种方案：</p>
<ol>
<li>在协议和方法前均加上 @objc 关键字，然后在可选方法前加上 optional 关键字。该方案实际上是把协议转化为 OC 的方式，然后进行分可选定义。</li>
<li>用扩展 extension 来规定可选方法。</li>
</ol>
<h5 id="协议的代码实战"><a class="markdownIt-Anchor" href="#协议的代码实战">#</a> 协议的代码实战</h5>
<p>记着一点就行，weak 只能为引用类型提供内存管理。所以协议有时候需要继承自 class。</p>
<h4 id="编程思路"><a class="markdownIt-Anchor" href="#编程思路">#</a> 编程思路</h4>
<h5 id="混编时方法如何互调"><a class="markdownIt-Anchor" href="#混编时方法如何互调">#</a> 混编时，方法如何互调？</h5>
<ul>
<li>Swift 调用 OC 方法时，使用 bridging 桥接头文件。</li>
<li>OC 调用 Swift ，则导入 Swift 文件生成的头文件。Swift 文件中对外暴露的属性或方法需加上 @objc 关键字。</li>
</ul>
<h5 id="比较-swift-和-objective-c-中初始化方法-init-有什么异同"><a class="markdownIt-Anchor" href="#比较-swift-和-objective-c-中初始化方法-init-有什么异同">#</a> 比较 Swift 和 Objective-C 中初始化方法 init 有什么异同</h5>
<p>一言以蔽之，Swift 中初始化方法更加严谨和准确。</p>
<ul>
<li>在 Objective-C 中，初始化方法无法保证所有成员变量都完成初始化；编译器对属性设置并无警告，但是实际操作会出现初始化不完全的情况。初始化方法和普通方法并无差异，可以多次调用。</li>
<li>在 Swift 中，初始化方法必须保证所有非 optional 的成员变量都完成初始化；同时，新增 convenience 和 required 两个修饰初始化方法的关键词。convenience 只是提供了一种方便的初始化方法（便利构造器），必须通过调用同一个类中的 designated 初始化方法（指定构造器）来完成。required 是强制子类重写父类中所修饰的初始化方法。</li>
</ul>
<h5 id="比较-swift-和-objective-c-中的协议有什么异同"><a class="markdownIt-Anchor" href="#比较-swift-和-objective-c-中的协议有什么异同">#</a> 比较 Swift 和 Objective-C 中的协议有什么异同</h5>
<p>相同点：都可以被用作代理。在实际开发中多用于适配器模式（Adapter Pattern）。</p>
<p>不同点：Swift 中的 protocol 还可以对接口进行抽象，例如 Sequence，配合扩展、泛型、关联类型等实现面向协议编程，从而大大提高代码灵活性。同时，Swift 中的 protocol 还能用于值类型，如结构体和枚举。</p>
<h4 id="语言特性"><a class="markdownIt-Anchor" href="#语言特性">#</a> 语言特性</h4>
<h5 id="谈谈对-objective-c-和-swift-对动态性的理解"><a class="markdownIt-Anchor" href="#谈谈对-objective-c-和-swift-对动态性的理解">#</a> 谈谈对 Objective-C 和 Swift 对动态性的理解</h5>
<p>runtime 其实就是 Objective-C 语言的动态机制。runtime 执行的是编译后的代码，这时它可以动态的添加对象、添加方法、修改属性、传递信息等。具体过程是，在 Objective-C 中，对象调用方法时，如  <code>[self.tableview reload];</code> ，经历了两个阶段：</p>
<ul>
<li>编译阶段：编译器（compiler）会把这句话翻译成  <code>objc_msgSend(self.tableview, @selector(reload)</code> ，把消息发送给 self.tableview。</li>
<li>运行阶段：接收者 self.tableview 会响应这个消息，其间可能直接执行、转发消息，也可能找不到方法而导致程序崩溃。崩溃过程以及预防措施，可参考 <a href="https://www.jianshu.com/p/9856cf221c2b">iOS：消息转发机制、响应者链、App 启动前后</a>。</li>
</ul>
<p>所以，整个流程是：编译器翻译 -&gt; 给接收者发送消息 -&gt; 接收者响应消息。</p>
<p>其中，接收者如何响应消息，就发生在运行时（runtime）。runtime 的运行时机制就是 Objective-C 的语言特性。</p>
<p>Swift 目前被公认为一门静态语言。它的动态特性都是通过桥接 OC 来实现的。</p>
<h5 id="语言特性的代码实战"><a class="markdownIt-Anchor" href="#语言特性的代码实战">#</a> 语言特性的代码实战</h5>
<p>这里牵扯到协议的派发。通下下面一段代码来说明：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Chef</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeFood</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Chef</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeFood</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Make Food&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SeafoodChef</span>: <span class="title class_">Chef</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeFood</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Cook Seafood&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> chefOne: <span class="type">Chef</span> <span class="operator">=</span> <span class="type">SeafoodChef</span>()</span><br><span class="line"><span class="keyword">let</span> chefTwo:  <span class="type">SeafoodChef</span> <span class="operator">=</span> <span class="type">SeafoodChef</span>()</span><br><span class="line">chefOne.makeFood()</span><br><span class="line">chefTwo.makeFood()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Cook</span> <span class="type">Seafood</span></span><br><span class="line"><span class="type">Cook</span> <span class="type">Seafood</span></span><br></pre></td></tr></table></figure>
<p>在 Swift 中，协议中是动态派发的，而扩展中则是静态派发的。也就是说，协议中如果有方法声明，那么方法会根据对象的实际类型进行调用。</p>
<p>如果上述代码中，将协议中  <code>func makeFood()</code>  方法删除，则输出变为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Make</span> <span class="type">Food</span></span><br><span class="line"><span class="type">Cook</span> <span class="type">Seafood</span></span><br></pre></td></tr></table></figure>
<p>因为协议中没有声明 makeFood () 方法，所以此时需要按照扩展中的协议静态派发。也就是说，会根据对象的声明类型进行调用，而非实际类型。</p>
<h5 id="message-send-如果找不到对象则会如何进行后续处理"><a class="markdownIt-Anchor" href="#message-send-如果找不到对象则会如何进行后续处理">#</a> message send 如果找不到对象，则会如何进行后续处理</h5>
<p>message send 找不到对象分两种情况：对象为空（nil）；对象不为空，却找不到对应的方法。</p>
<ul>
<li>对象为空时，Objective-C 向 nil 发送消息是有效的，在 runtime 中不会产生任何效果。</li>
<li>对象不为空，却找不到对应的方法时，程序运行异常，引发 unrecognized selector 错误。</li>
</ul>
<h5 id="什么是-method-swizzling"><a class="markdownIt-Anchor" href="#什么是-method-swizzling">#</a> 什么是 method swizzling</h5>
<p>每个类都维护一个方法列表，其中方法名与其实现是一一对应的关系，即 SEL (方法名) 和 IMP (指向实现的指针) 的对应关系。method swizzling 可以在 runtime 期间将 SEL 和 IMP 进行更换。更换时需注意：</p>
<ul>
<li>方法交换应该保证唯一性和原子性。唯一性是指应该尽可能的在 +load () 方法中实现，这样可以保证方法一定会被调用且不会异常。原子性是指需要使用 dispatch_once 来执行方法交换，这样可以保证只运行一次。</li>
<li>不要轻易使用 method swizzling。因为动态交换方法的实现并没有编译器的安全保障，可能会在运行时造成奇怪的问题。</li>
</ul>
<h5 id="swift-和-objective-c-的自省introspection有什么不同"><a class="markdownIt-Anchor" href="#swift-和-objective-c-的自省introspection有什么不同">#</a> Swift 和 Objective-C 的自省（Introspection）有什么不同</h5>
<p>自省在 Objective-C 中就是：判断一个对象是否属于某个类的操作、它有以下两种形式：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[obj isKindOfClass:[SomeClass <span class="keyword">class</span>]];</span><br><span class="line">[obj isMemberOfClass:[SomeClass <span class="keyword">class</span>]];</span><br></pre></td></tr></table></figure>
<p>isKindOfClass 用来判断 obj 是否是 SomeClass 或其子类。isMemberOfClass 用来判断 obj 是否就是 SomeClass（非子类）的实例对象。这两个方法都有个前提：obj 必须是 NSObject 或其子类。</p>
<p>在 Swift 中，由于很多类型并非继承自 NSObject，所以通常用 is 函数来进行判断，相当于 isKindOfClass。is 函数可同时用于值类型和引用类型。</p>
<p>另外，自省通常与动态类型一起使用。动态类型就是 id 类型。</p>
<h5 id="能够通过-category-给已有类添加属性-property"><a class="markdownIt-Anchor" href="#能够通过-category-给已有类添加属性-property">#</a> 能够通过 Category 给已有类添加属性 property</h5>
<p>不论对 OC 还是 Swift，都可以添加。如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> middleKey: <span class="type">Void</span>?</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> middleName: <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="operator">&amp;</span>middleKey) <span class="keyword">as?</span> <span class="type">String</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, <span class="operator">&amp;</span>middleKey, newValue, objc_AssociationPolicy.<span class="type">OBJC_ASSOCIATION_COPY_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setter 方法使用 objc_setAssociatedObject，getter 方法使用 objc_getAssociatedObject 即可。</p>
<h3 id="xcode-使用"><a class="markdownIt-Anchor" href="#xcode-使用">#</a> Xcode 使用</h3>
<h4 id="xcode-调试"><a class="markdownIt-Anchor" href="#xcode-调试">#</a> Xcode 调试</h4>
<h5 id="lldb-中-p-和-po-有什么区别"><a class="markdownIt-Anchor" href="#lldb-中-p-和-po-有什么区别">#</a> LLDB  中 p 和 po 有什么区别</h5>
<ul>
<li>p 是 expr- 的缩写。它的工作是把收到的参数在当前环境下进行编译，然后打印出对应的值。</li>
<li>po 即 expr-o-。会打印出比 p 更加详细的内容。</li>
</ul>
<h4 id="分析与优化"><a class="markdownIt-Anchor" href="#分析与优化">#</a> 分析与优化</h4>
<h5 id="app-启动时间过长该怎样优化"><a class="markdownIt-Anchor" href="#app-启动时间过长该怎样优化">#</a> App 启动时间过长，该怎样优化</h5>
<p><a href="https://www.jianshu.com/p/9856cf221c2b">iOS：消息转发机制、响应者链、App 启动前后</a>。这篇文章里也说过这个问题。这里只重复说一点：</p>
<p>通过添加环境变量可以打印出 App 的启动时间分析:</p>
<p>Edit scheme -&gt; Run -&gt; Arguments -&gt; Environment Variables:</p>
<ul>
<li>添加：DYLD_PRINT_STATISTICS，设置为 1。</li>
<li>如果需要更详细的信息，那就添加：DYLD_PRINT_STATISTICS_DETAILS，设置为 1。</li>
</ul>
<h5 id="如何用-xcode-检测代码中的循环引用"><a class="markdownIt-Anchor" href="#如何用-xcode-检测代码中的循环引用">#</a> 如何用 Xcode 检测代码中的循环引用</h5>
<p>两种方案：</p>
<ol>
<li>Xcode 调试工具栏中的 Memory Debug Graph 工具。</li>
<li>Instruments 里面的 leak，一个专门检测内存泄露的工具。</li>
</ol>
<h5 id="怎样解决-exc_bad_access"><a class="markdownIt-Anchor" href="#怎样解决-exc_bad_access">#</a> 怎样解决 EXC_BAD_ACCESS</h5>
<p>产生 EXC_BAD_ACCESS 的主要原因就是访问了已经释放的对象，或者访问他们已经释放了的成员变量或者方法，解决方法主要有以下几种：</p>
<ul>
<li>设置全局断点，快速定位缺陷所在：这种方法效果一般。</li>
<li>重写 Object 的 repondsToSelector 方法：这种方法效果一般，并且要在每个 class 进行定点排查，并不推荐。</li>
<li>使用 Zombie 和 Address Sanitizer: 可以在绝大部分情况下定位到问题代码。开启方式：Edit scheme -&gt; Run -&gt; Diagnostics -&gt; Address Sanitizer 和 Zombie Objects 选项。</li>
</ul>
<h4 id="playground-技巧"><a class="markdownIt-Anchor" href="#playground-技巧">#</a> Playground 技巧</h4>
<h5 id="如何在-playground-中执行异步操作"><a class="markdownIt-Anchor" href="#如何在-playground-中执行异步操作">#</a> 如何在 Playground 中执行异步操作</h5>
<p>要让 Playground 具备延时运行的特性，可以在 Playground 文件中加入以下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> PlaygroundSupport</span><br><span class="line"><span class="type">PlaygroundPage</span>.current.needsIndefiniteException <span class="operator">=</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h5 id="playground-可视化"><a class="markdownIt-Anchor" href="#playground-可视化">#</a> Playground 可视化</h5>
<p>导入头文件即可:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> PlaygroundSupport</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_">UIViewConrollwe</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="系统框架"><a class="markdownIt-Anchor" href="#系统框架">#</a> 系统框架</h2>
<h3 id="ui-相关知识"><a class="markdownIt-Anchor" href="#ui-相关知识">#</a> UI 相关知识</h3>
<h4 id="ui-控件和基本布局"><a class="markdownIt-Anchor" href="#ui-控件和基本布局">#</a> UI 控件和基本布局</h4>
<h5 id="stroyboardxib-和纯代码构建的-ui-相比有哪些优点和缺点"><a class="markdownIt-Anchor" href="#stroyboardxib-和纯代码构建的-ui-相比有哪些优点和缺点">#</a> stroyboard/xib 和纯代码构建的 UI 相比，有哪些优点和缺点</h5>
<p>优点：</p>
<ul>
<li>简单直接快速。</li>
<li>跳转关系清除</li>
</ul>
<p>缺点:</p>
<ul>
<li>多人协作易冲突。</li>
<li>很难做到界面继承和重用。</li>
<li>不便进行模块化管理。</li>
<li>影响性能。</li>
</ul>
<blockquote>
<p>PS. 吐个槽，我自己经常用 xib，看到这里的对比，，，自己看着办吧。</p>
</blockquote>
<h5 id="auto-layout-和-frame-在-ui-布局和渲染上有什么区别"><a class="markdownIt-Anchor" href="#auto-layout-和-frame-在-ui-布局和渲染上有什么区别">#</a> Auto Layout 和 Frame 在 UI 布局和渲染上有什么区别</h5>
<ul>
<li>Auto Layout 是针对多尺寸屏幕的设计。其本质是通过线性不等式设置 UI 控件的相对位置，从而适配多种屏幕尺寸。</li>
<li>Frame 是基于 X、Y 坐标轴的布局机制。是开发中最底层、最基本的页面布局。</li>
<li>Auto Layout 的性能比 Frame 差很多。（其实最近两年 Xcode 升级对这个已经进行过大幅度优化了）。</li>
<li>优化 Auto Layout 的方案是减少视图层级，减少计算量，缓存计算结果等。</li>
</ul>
<h5 id="uiview-和-calayer-有什么区别"><a class="markdownIt-Anchor" href="#uiview-和-calayer-有什么区别">#</a> UIView 和 CALayer 有什么区别</h5>
<ul>
<li><strong>UIView 和 CALayer 都是 UI 操作的对象</strong>。两者都是 NSObject 的子类，发生在 UIView 上的操作，本质上发生在对应的 CALayer 上。</li>
<li><strong>UIView 是 CALayer 用户交互的对象</strong>。UIView 是 UIResponder 的子类，其中提供了很多 CALayer 所没有的交互上的接口，主要负责处理用户触发的各种操作。</li>
<li><strong>CALayer 在图像和动画渲染上性能更好</strong>。这是因为 UIView 有冗余的交互接口，而且相比 CALayer，有层级之分。CALayer 无需处理交互时进行渲染，可以节省大量时间。</li>
</ul>
<h5 id="说明比较关键词-framebounds-和-center"><a class="markdownIt-Anchor" href="#说明比较关键词-framebounds-和-center">#</a> 说明比较关键词： frame，bounds 和 center</h5>
<ul>
<li><strong>frame</strong> 是指当前视图（View）相对于父视图的平面坐标系统中的位置和大小。</li>
<li><strong>bounds</strong> 是指当前视图相对于自己的平面坐标系统中的位置和大小。</li>
<li><strong>center</strong> 是一个 CGPoint，指当前视图在父视图的平面坐标系统中，中间的位置。</li>
</ul>
<p>另外，frame 和 bounds 的 size 并非一直相等，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oneV <span class="operator">=</span> <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">30</span>, y: <span class="number">100</span>, width: <span class="number">100</span>, height: <span class="number">180</span>))</span><br><span class="line">oneV.transform3D <span class="operator">=</span> <span class="type">CATransform3DMakeRotation</span>(<span class="number">30</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">oneV.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.red</span><br><span class="line">view.addSubview(oneV)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;oneV frame = <span class="subst">\(oneV.frame)</span><span class="subst">\n</span>oneV bounds = <span class="subst">\(oneV.bounds)</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">oneV frame <span class="operator">=</span> (<span class="operator">-</span><span class="number">18.520467338700882</span>, <span class="number">136.31870596839138</span>, <span class="number">197.04093467740176</span>, <span class="number">107.36258806321723</span>)</span><br><span class="line">oneV bounds <span class="operator">=</span> (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">100.0</span>, <span class="number">180.0</span>)</span><br></pre></td></tr></table></figure>
<h5 id="说明并比较方法layoutifneededlayoutsubviews-和-setneedslayout"><a class="markdownIt-Anchor" href="#说明并比较方法layoutifneededlayoutsubviews-和-setneedslayout">#</a> 说明并比较方法：layoutIfNeeded，layoutSubviews 和 setNeedsLayout</h5>
<ul>
<li><strong>layoutIfNeeded</strong> 一旦被调用，主线程会立即强制重新布局，它从当前视图开始，一直到完成所有子视图的布局。</li>
<li><strong>layoutSubviews</strong> 用来自定义视图尺寸。它是系统自动调用的，开发者不能手动调用。我们能做的就是重写该方法，让系统调整尺寸时按照我们期望的效果进行布局。这个方法主要用在屏幕旋转、滑动或者触摸界面、修改子视图时被触发。</li>
<li><strong>setNeedsLayout</strong> 与 layoutIfNeeded 非常相似，唯一不同就是它不会立即刷新布局，而是在下一个布局周期才会触发刷新。</li>
</ul>
<h5 id="说明并比较关键词-safe-area-safearealayoutguide-和-safeareainsets"><a class="markdownIt-Anchor" href="#说明并比较关键词-safe-area-safearealayoutguide-和-safeareainsets">#</a> 说明并比较关键词： Safe Area, SafeAreaLayoutGuide 和 SafeAreaInsets</h5>
<p>由于 iPhone X 采用了全新的 “刘海” 设计，所以 iOS11 中引入了安全区域（Safe Area）的概念。</p>
<ul>
<li><strong>Safe Area 是指 App 合理显示内容的区域</strong>。它不包括 status bar, navigation bar, tab bar 和 tool bar 等。在 iPhoneX 系列中，一般是指扣除了顶部的 status bar（高度 44 像素）和底部的 home indicator（高度 34 像素）的区域。</li>
<li><strong>SafeAreaLayoutGuide 是指 Safe Area 的区域范围和限制</strong>。在布局设置中可取其上下左右进行设置。</li>
<li><strong>SafeAreaInsets 限定了 Safe Area 区域和整个屏幕之间的布局关系</strong>。</li>
</ul>
<h4 id="动画"><a class="markdownIt-Anchor" href="#动画">#</a> 动画</h4>
<h5 id="ios-中动画实现方式有几种"><a class="markdownIt-Anchor" href="#ios-中动画实现方式有几种">#</a> iOS 中动画实现方式有几种</h5>
<p>主要有以下三种：</p>
<ul>
<li><strong>UIView Animation 可以实现基于 UIView 的简单动画</strong>。它是 CALayer Animation 的封装。它实现的动画无法回撤、暂定、与手势交互。</li>
<li><strong>CALayer Animation 是在更底层 CALayer 上的动画接口</strong>。可以实现 UIView Animation 以及更多自定义效果。支持动画的回撤、暂停与手势交互。</li>
<li><strong>UIViewPropertyAnimator 是 iOS10 中引入的处理交互式动画的接口</strong>。相比 UIView Animation，更加方便，且支持手势交互。</li>
</ul>
<h5 id="控制屏幕上小球使其水平右移-200-个-point"><a class="markdownIt-Anchor" href="#控制屏幕上小球使其水平右移-200-个-point">#</a> 控制屏幕上小球，使其水平右移 200 个 point</h5>
<p>嗯，，，真的问了这个问题，就要追问更多的细节再去编码。实现方案就是动画位移。</p>
<h4 id="多任务开发"><a class="markdownIt-Anchor" href="#多任务开发">#</a> 多任务开发</h4>
<h5 id="在-ios-开发中如何保证-app-的-ui-在-iphone-ipad-以及-ipad-分屏情况下依然适用"><a class="markdownIt-Anchor" href="#在-ios-开发中如何保证-app-的-ui-在-iphone-ipad-以及-ipad-分屏情况下依然适用">#</a> 在 iOS 开发中，如何保证 App 的 UI 在 iPhone、iPad 以及 iPad 分屏情况下依然适用</h5>
<p>为适应各种机型，苹果公司在 iOS8 中引入了 Adaptive UI 的概念，需注意以下几点：</p>
<ul>
<li>采用 Auto Layout。</li>
<li>采用 Size Class。</li>
<li>关注多屏情况。</li>
</ul>
<h5 id="如何用-drag-drop-实现图片拖动功能"><a class="markdownIt-Anchor" href="#如何用-drag-drop-实现图片拖动功能">#</a> 如何用 drag &amp; drop 实现图片拖动功能</h5>
<p>iOS11 中最新引入的 Drag and Drop 功能。</p>
<h3 id="uiscrollview-及其子类"><a class="markdownIt-Anchor" href="#uiscrollview-及其子类">#</a> UIScrollView 及其子类</h3>
<h4 id="uiscrollview-及其子类理论面试题"><a class="markdownIt-Anchor" href="#uiscrollview-及其子类理论面试题">#</a> UIScrollView 及其子类理论面试题</h4>
<h5 id="说明并比较关键词contentview-contentinset-contentsize-和-contentoffset"><a class="markdownIt-Anchor" href="#说明并比较关键词contentview-contentinset-contentsize-和-contentoffset">#</a> 说明并比较关键词：contentView, contentInset, contentSize 和 contentOffset</h5>
<ul>
<li><strong>UIScrollView 上显示内容的区域被称为 contentView</strong>。</li>
<li><strong>contentInset 是指 contentView 与 UIScrollView 的边界</strong>。具体属性包括 top、bottom、left 和 right 四个。</li>
<li><strong>contentSize 值 contentView 的大小</strong>。</li>
<li><strong>contentOffset 是指当前 contentView 浏览位置左上角点的坐标</strong>。它是相对于整个 UIScrollView 左上角为原点而言的。</li>
</ul>
<h5 id="说明-uitableviewcell-的重用机制"><a class="markdownIt-Anchor" href="#说明-uitableviewcell-的重用机制">#</a> 说明 UITableViewCell 的重用机制</h5>
<p>相同类型的 UITableViewCell 标记为相同的 Identifier，然后用 reuseIdentifier 进行构建。不用重复生成新的 Cell。</p>
<h5 id="说明并比较协议-uitableviewdatasource-和-uitableviewdelegate"><a class="markdownIt-Anchor" href="#说明并比较协议-uitableviewdatasource-和-uitableviewdelegate">#</a> 说明并比较协议 UITableViewDataSource 和 UITableviewDelegate</h5>
<ul>
<li>UITableViewDataSource 用来管控 UITableView 的实际数据。例如多少行、每行多高等。</li>
<li>UITableviewDelegate 用来处理 UITableView 的 UI 交互，如设置 header 和 footer、点击、推动、删除等。</li>
</ul>
<h5 id="说明并比较协议uicollectionviewdatasource-uicollectionviewdelegate-uicollectionviewdelegateflowlayout"><a class="markdownIt-Anchor" href="#说明并比较协议uicollectionviewdatasource-uicollectionviewdelegate-uicollectionviewdelegateflowlayout">#</a> 说明并比较协议：UICollectionViewDataSource, UICollectionViewDelegate, UICollectionViewDelegateFlowLayout</h5>
<ul>
<li>UICollectionViewDataSource 管控 UICollectionView 的实际数据。</li>
<li>UICollectionViewDelegate 用来处理交互。</li>
<li>UICollectionViewDelegateFlowLayout 用来处理 UICollectionView 的布局及其行为，如滚动方向。</li>
</ul>
<h5 id="uicollectionview-中的-supplementary-views-和-decoration-views-分别指什么"><a class="markdownIt-Anchor" href="#uicollectionview-中的-supplementary-views-和-decoration-views-分别指什么">#</a> UICollectionView 中的 Supplementary Views 和 Decoration Views 分别指什么</h5>
<p><strong>Cells，Supplementary Views 和 Decoration Views 共同构成了整个 UICollectionView 的视图</strong>。 Cells 是最基本的，并且必须由用户实现和配置。而 Supplementary Views 和 Decoration Views 有默认实现，用来美化 UICollectionView。</p>
<h4 id="优化进阶"><a class="markdownIt-Anchor" href="#优化进阶">#</a> 优化进阶</h4>
<h5 id="如果一个列表视图滑动很慢那么该怎样优化"><a class="markdownIt-Anchor" href="#如果一个列表视图滑动很慢那么该怎样优化">#</a> 如果一个列表视图滑动很慢，那么该怎样优化</h5>
<p>遇到此问题，第一步要分析原因。列表视图滑动不流畅，肯定是 UI 或者数据除了问题，可能的原因是：</p>
<ul>
<li>类表渲染时间较长。可能因为某些 UI 控件比较复杂，或者图层过多。</li>
<li>界面渲染延后。可能是大量的操作或者耗时计算阻塞的主线程。</li>
<li>数据源问题。可能因为网络请求太慢，不能及时得到响应数据。也有可能需要数据太多，主线程不能及时处理。</li>
</ul>
<p>针对上面三个问题，分别优化：</p>
<ul>
<li>对于第一个问题，首先检查 Cell 是否复用，是否有复杂图层，也可使用惰性加载来推迟创建时间。也可采用 Facebook 推出的 ComponentKit 进行优化。</li>
<li>对于第二个问题，可采用 GCD 将耗时操作放到子线程处理，并进行缓存。如果 LinkedIn 推出的 LayoutKit 就是很好的例子。</li>
<li>对于第三个问题，可以缓存后端数据，或者和后端协调优化网络请求。</li>
</ul>
<p>对于界面渲染和优化，Facebook 和 Pinterest 维护的 ASDK 是目前功能最全、效果最好、使用最广的第三方解决方案。</p>
<h5 id="说一说实现预加载的方法"><a class="markdownIt-Anchor" href="#说一说实现预加载的方法">#</a> 说一说实现预加载的方法</h5>
<p>即滑动过程中请求新的数据。简单实现方案如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">scrollViewDidScroll</span>(<span class="keyword">_</span> <span class="params">scrollView</span>: <span class="type">UIScrollView</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> current <span class="operator">=</span> scrollView.contentOffset.y <span class="operator">+</span> scrollView.frame.size.height</span><br><span class="line">    <span class="keyword">let</span> totol <span class="operator">=</span> scrollView.contentSize.height</span><br><span class="line">    <span class="keyword">let</span> ratio <span class="operator">=</span> current <span class="operator">/</span> totol</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> needRead <span class="operator">=</span> cellsPerPage <span class="operator">*</span> threshold <span class="operator">+</span> currentPage <span class="operator">*</span> cellPerPage</span><br><span class="line">    <span class="keyword">let</span> totolCells <span class="operator">=</span> cellsPerPage <span class="operator">*</span> (currentPage <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> newTheshold <span class="operator">=</span> needRead <span class="operator">/</span> totolCells</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ratio <span class="operator">&gt;=</span> newTheshold &#123;</span><br><span class="line">        currentPage <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        requestNewPage()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以参考 ASDK 做更进一步的优化。</p>
<h5 id="如何用-uicollectionview-实现瀑布流界面"><a class="markdownIt-Anchor" href="#如何用-uicollectionview-实现瀑布流界面">#</a> 如何用 UICollectionView 实现瀑布流界面</h5>
<p>创建一个 UICollectionViewlayout 的子类，并对以下四个属性或方法一一设定：</p>
<ul>
<li>collectionViewContentSize，瀑布流的尺寸变化，必然要重写这个属性。</li>
<li>prepare ()。该方法发生在 UICollectionView 数据准备好，但界面还未布局之时。在这里进行位置计算。</li>
<li>layoutAttributesForElements (in:)。prepare () 完成布局后，调用该方法，决定展示哪些 item。</li>
<li>layoutAttributesForItem (at:)。该方法对每一个 item 设定 layoutAttributes。</li>
</ul>
<p>实现一个瀑布流需要复杂的计算和测试，这里仅仅是提供思路。</p>
<h3 id="网络-推送与数据处理"><a class="markdownIt-Anchor" href="#网络-推送与数据处理">#</a> 网络、推送与数据处理</h3>
<h4 id="网络-推送与数据处理相关理论"><a class="markdownIt-Anchor" href="#网络-推送与数据处理相关理论">#</a> 网络、推送与数据处理相关理论</h4>
<h5 id="说一下-http-中-get-和-post-的区别"><a class="markdownIt-Anchor" href="#说一下-http-中-get-和-post-的区别">#</a> 说一下 HTTP 中 GET 和 POST 的区别</h5>
<ul>
<li>从方向上看，GET 是从服务器获取信息的，POST 是想服务器发送信息的。实质上，他们都能够获取、发送信息。</li>
<li>从类型看，GET 处理静态和动态内容，POST 只处理动态内容。</li>
<li>从参数位置看，GET 参数才 URI 里，POST 参数在其包体里。从这个角度来看，POST 比 GET 更安全、隐秘。</li>
<li>GET 可以被缓存，可以被存储在浏览器的浏览历史里，其内容理论上有长度限制，而 POST 在这三方面恰恰相反。</li>
</ul>
<blockquote>
<p>PS. 感觉这里说的宽泛而不严谨，关于 HTPP 更多信息，可以参考书籍《图解 HTTP》。</p>
</blockquote>
<h5 id="说一说-session-和-cookie-的概念"><a class="markdownIt-Anchor" href="#说一说-session-和-cookie-的概念">#</a> 说一说 Session 和 Cookie 的概念</h5>
<ul>
<li>Session 是服务器用来认证、追踪用户的数据结构。它通过判断客户端传来的消息确定用户。确定用户的唯一标志就是客户端传来的 Session ID。</li>
<li>Cookie 是客户端用来保存用户信息的机制。初次会话时，HTTP 协议会在 Cookie 里记录一个 Session ID，之后每次会话都把 Session ID 发给服务器。</li>
<li>Session 一般用于用户验证。它默认存储在服务器的一个文件里，当然也可以存储在内存、数据库里。</li>
<li>若客户端禁用了 Cookie，则客户端会用 URL 重写技术，即绘画板时在 URL 的末尾加上 Session ID，并发送给服务器。</li>
</ul>
<h5 id="说明并比较网络通信协议ajax-polling-long-polling-websockets-和-server-sent-event"><a class="markdownIt-Anchor" href="#说明并比较网络通信协议ajax-polling-long-polling-websockets-和-server-sent-event">#</a> 说明并比较网络通信协议：Ajax Polling, Long Polling, WebSockets 和 Server-Sent Event。</h5>
<p>。。。</p>
<h5 id="在一个-https-连接的网站中输入账号和密码并单击登录按钮后到服务器返回这个请求前这期间经历了什么"><a class="markdownIt-Anchor" href="#在一个-https-连接的网站中输入账号和密码并单击登录按钮后到服务器返回这个请求前这期间经历了什么">#</a> 在一个 HTTPS 连接的网站中，输入账号和密码，并单击登录按钮后，到服务器返回这个请求前，这期间经历了什么</h5>
<p>具体经历以下 8 步：</p>
<ol>
<li><strong>客户端打包请求</strong>。其中包括 URL、端口、账号密码等。<strong>注意</strong>，HTTPS，即 HTTP + SSL/TLS，在 HTTP 上又加了一层处理加密信息的模板。这个过程相当于客户端请求钥匙。</li>
<li><strong>服务端接受请求</strong>。这个过程中，DNS 把网络地址解析成 IP 地址，在寻找到对应的计算机。<strong>这个过程相当于服务器分析是否要向客户端发送钥匙模板</strong>。</li>
<li><strong>服务器返回数字证书</strong>。这个过程相当于服务器想客户端发送钥匙模板。</li>
<li><strong>客户端生成加密信息</strong>。此时信息已被加密，这个过程相当客户端生成钥匙并锁上请求。</li>
<li><strong>客户端发送加密信息</strong>。即客户端发送请求。</li>
<li><strong>服务器加锁加密信息</strong>。</li>
<li><strong>服务器向客户端返回信息</strong>。</li>
<li><strong>客户端解锁返回信息</strong>。</li>
</ol>
<h4 id="ios-网络请求"><a class="markdownIt-Anchor" href="#ios-网络请求">#</a> iOS 网络请求</h4>
<h5 id="说明并比较类urlsessiontask-urlsessiondatatask-urlsessionuploadtask-urlsessiondownloadtask"><a class="markdownIt-Anchor" href="#说明并比较类urlsessiontask-urlsessiondatatask-urlsessionuploadtask-urlsessiondownloadtask">#</a> 说明并比较类：URLSessionTask, URLSessionDataTask, URLSessionUploadTask, URLSessionDownloadTask</h5>
<ul>
<li><strong>URLSessionTask</strong> 是一个抽象类。通过实现它，可以实现网络的任务传输任务。诸如请求、上传、下载任务。它的取消、继续、暂停方法有默认实现。</li>
<li><strong>URLSessionDataTask</strong> 负责 HTTP GET 请求，一般用户获取服务器数据。</li>
<li><strong>URLSessionUploadTask</strong> 负责 HTTP POST/PUT 请求，一般用于上传数据。</li>
<li><strong>URLSessionDownloadTask</strong> 负责下载数据，如断点下载功能。</li>
</ul>
<h5 id="什么是-completion-handler"><a class="markdownIt-Anchor" href="#什么是-completion-handler">#</a> 什么是 Completion Handler</h5>
<p>Completion Handler 一般用于处理 API 请求后的返回数据。</p>
<h4 id="消息推送"><a class="markdownIt-Anchor" href="#消息推送">#</a> 消息推送</h4>
<h5 id="在-ios-开发中本地消息推送的流程是怎样的"><a class="markdownIt-Anchor" href="#在-ios-开发中本地消息推送的流程是怎样的">#</a> 在 iOS 开发中，本地消息推送的流程是怎样的</h5>
<p>UserNotification 框架是针对远程和本队消息的框架，其流程主要有以下 4 步：</p>
<ol>
<li>注册。通过调用 requestAuthiruzatuion，让用户在 Alert 中进行选择。</li>
<li>创建。</li>
<li>推送。</li>
<li>响应。</li>
</ol>
<p>远程推送与本地推送的差异在于第二步，推送信息的创建。</p>
<h5 id="说一说-ios-开发中远程推送的原理"><a class="markdownIt-Anchor" href="#说一说-ios-开发中远程推送的原理">#</a> 说一说 iOS 开发中，远程推送的原理</h5>
<p>这个问题主要是理清 iOS 系统、App、APNs 服务器以及 App 对应的客户端的关系，主要包括以下几方面：</p>
<ol>
<li>App 向 iOS 系统申请远程推送消息的权限。这与本地消息推送的注册是一致的。</li>
<li>iOS 系统想 APNs 服务器请求手机端的 deviceToken，并告诉 App，允许接收推送的通知。</li>
<li>App 接收到手机端的 deviceToken。</li>
<li>App 将收到的 deviceToken 传给 App 的服务器端。</li>
<li>远程消息由 App 对应的服务器端产生吗，它会先经过 APNs 服务器。</li>
<li>APNs 服务器将远程通知推送给响应的手机。</li>
<li>根据对应的 deviceToken，通知会推送到指定的手机。</li>
</ol>
<h4 id="数据处理"><a class="markdownIt-Anchor" href="#数据处理">#</a> 数据处理</h4>
<h5 id="在-ios开发中如何实现编码和解码"><a class="markdownIt-Anchor" href="#在-ios开发中如何实现编码和解码">#</a> 在 iOS 开发中，如何实现编码和解码</h5>
<p>在 Swift4 中，编码和解码引入了 Encodable 和 Decodable 这两个协议，而 Codable 是这两个协议的合集，在 Swift 中，Enum、Struct 和 Class 都支持 Codable。</p>
<h5 id="说一说-ios-开发中数据持久化方案"><a class="markdownIt-Anchor" href="#说一说-ios-开发中数据持久化方案">#</a> 说一说 iOS 开发中数据持久化方案</h5>
<ul>
<li>Plist。一般用于保存 App 的基本参数。</li>
<li>Preference。即使用 UserDefaults 来保存，本质是相关数据保存到同一个 plist 文件下。</li>
<li>NSKeyedArchiver。序列化方案，即归档和解档。</li>
<li>CoreData。以上三种都是覆盖存储。CoreData 则是数据库存储，此外还有 SQLite3、FMDB、Realm 等。</li>
</ul>
<h3 id="并发编程"><a class="markdownIt-Anchor" href="#并发编程">#</a> 并发编程</h3>
<h4 id="在-ios-开发中并发操作有哪-3-种方式"><a class="markdownIt-Anchor" href="#在-ios-开发中并发操作有哪-3-种方式">#</a> 在 iOS 开发中，并发操作有哪 3 种方式</h4>
<ul>
<li><strong>NSThread:</strong> 可以最大限度的掌握每一个线程的生命周期。但需要开发者手段管理以及加锁操作。使用场景较小，基本是在开发底层的开源软件或者测试时调用。</li>
<li><strong>GCD(Grand Central Dispatch):</strong> 苹果公司推荐，为了追求高效处理大量并发数据。</li>
<li><strong>Operation:</strong> 与 GCD 类似，但是更加灵活。</li>
</ul>
<h4 id="比较关键词-serial-concurrent-sync-async"><a class="markdownIt-Anchor" href="#比较关键词-serial-concurrent-sync-async">#</a> 比较关键词： Serial、Concurrent、Sync、Async</h4>
<p>串行、并行、同步、异步，更多详细信息，可参考 <a href="https://www.jianshu.com/p/ef519348c733">《Objective-C 高级编程》三篇总结之三：GCD 篇</a>。</p>
<p>另外，并发编程三大问题、GCD 信号量、栅栏等，都可参考这篇文章。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>《iOS面试之道》两篇总结之二：算法基础篇</title>
    <url>/2022/09/07/%E3%80%8AiOS%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%8B%E4%B8%A4%E7%AF%87%E6%80%BB%E7%BB%93%E4%B9%8B%E4%BA%8C%EF%BC%9A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<p>《iOS 面试之道》是故胤道长和唐巧 2018 年合著的针对面试一些问题的书，买之后虽有翻阅，但是始终未认真通读。现在想把书中对于我来说有价值的知识点，简短的总结一下。这里分两篇来说，这篇主要是介绍一些算法基础。</p>
<span id="more"></span>
<p><a href="">《iOS 面试之道》两篇总结之一：开发技能篇</a></p>
<p><a href="">《iOS 面试之道》两篇总结之二：算法基础篇</a></p>
<h2 id="基本的数据结构"><a class="markdownIt-Anchor" href="#基本的数据结构">#</a> 基本的数据结构</h2>
<h3 id="数组"><a class="markdownIt-Anchor" href="#数组">#</a> 数组</h3>
<ul>
<li>ContiguousArray<Element>: 效率最高，元素分配在连续的内存地址上。如果数组元素是值类型，Swift 自动调用这种实现。处理大量元素时，推荐这种方式。</li>
<li>Array<Element>: 自动桥接到 Objective-C 的 NSArray 上，如果元素时值类型，与 ContiguousArray 性能无差别。</li>
<li>ArraySlice<Element>: 它不是一个新的数组，而只是一个片段，在内存上与数组享用同一区域。</li>
</ul>
<p>下面用数组实现一个栈操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stack: [<span class="type">AnyObject</span>]</span><br><span class="line">    <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">return</span> stack.isEmpty &#125;</span><br><span class="line">    <span class="keyword">var</span> peel: <span class="type">AnyObject</span>? &#123; <span class="keyword">return</span> stack.last &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        stack <span class="operator">=</span> [<span class="type">AnyObject</span>]()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">push</span>(<span class="params">object</span>: <span class="type">AnyObject</span>) &#123;</span><br><span class="line">        stack.append(object)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span>isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> stack.removeLast()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后强调一个操作： <code>reserveCapacity()</code> 。用于为原数组预留空间，防止数组数组添加或删除元素时反复申请内存空间或创建新数组。再别在数组创建或者  <code>removeAll()</code>  时，对整段代码起到性能提升的作用。</p>
<h3 id="字典和集合"><a class="markdownIt-Anchor" href="#字典和集合">#</a> 字典和集合</h3>
<p>一般字典和集合的 Key 都要遵循 Hashable 协议，自定义的类型作为 Key 实现 Hashable。这里说下集合的一些特点:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> primeNums: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line"><span class="keyword">let</span> oddNums: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment">/// 交集、并集、差集</span></span><br><span class="line"><span class="keyword">let</span> primeAndOddNum <span class="operator">=</span> primeNums.intersection(oddNums)</span><br><span class="line"><span class="keyword">var</span> orNums <span class="operator">=</span> primeNums</span><br><span class="line">orNums.formUnion(oddNums)</span><br><span class="line"><span class="keyword">let</span> primeNotOddNum <span class="operator">=</span> primeNums.subtracting(oddNums)</span><br></pre></td></tr></table></figure>
<p>这里一个字典的例子非常有意思：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 用字典和高阶函数计算字符串中每个字符出现的频率。</span></span><br><span class="line"><span class="comment">* 结果为 [&quot;l&quot;: 2, &quot;h&quot;: 1, &quot;o&quot;: 1, &quot;e&quot;: 1]</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="type">Dictionary</span>(<span class="string">&quot;hello&quot;</span>.map &#123; (<span class="variable">$0</span>, <span class="number">1</span>)&#125;, uniquingKeysWith: <span class="operator">+</span>)</span><br></pre></td></tr></table></figure>
<p>算法题： 给出一个整型数组和一个目标值，判断数组中是否有两个数之和等于目标值。</p>
<p>可利用目标减去差值的方式，时间复杂度为 <em>O(n)</em>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">twoNum</span>(<span class="params">nums</span>: [<span class="type">Int</span>], <span class="keyword">_</span> <span class="params">target</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">set</span> <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">set</span>.contains(target <span class="operator">-</span> num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>.insert(num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果修改这个题：给出一个整型数组有且仅有两个数之和等于目标值，求这两个数在数组中的序号。</p>
<p>这里使用字典记录序号，时间复杂度依然为  <em>O(n)</em>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">twoNum</span>(<span class="params">nums</span>: [<span class="type">Int</span>], <span class="keyword">_</span> <span class="params">target</span>: <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> dic <span class="operator">=</span> [<span class="type">Int</span>: <span class="type">Int</span>]()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> nums.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> lastIndex <span class="operator">=</span> dic[target <span class="operator">-</span> value] &#123;</span><br><span class="line">            <span class="keyword">return</span> [index, lastIndex]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dic[value] <span class="operator">=</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串">#</a> 字符串</h3>
<h4 id="给出一个字符串要求其按照单词顺序进行反转"><a class="markdownIt-Anchor" href="#给出一个字符串要求其按照单词顺序进行反转">#</a> 给出一个字符串，要求其按照单词顺序进行反转</h4>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    <span class="built_in">print</span>(reverseWords(s: <span class="string">&quot;the sky     is      blue&quot;</span>) <span class="operator">??</span> <span class="string">&quot;None&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 按照单词反转字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">reverseWords</span>(<span class="params">s</span>: <span class="type">String</span>?) -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> s <span class="operator">=</span> s <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> chars <span class="operator">=</span> s.map &#123; <span class="variable">$0</span> &#125;</span><br><span class="line">    reverse(<span class="operator">&amp;</span>chars, <span class="number">0</span>, chars.count <span class="operator">-</span> <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(chars)</span><br><span class="line">    <span class="keyword">var</span> start <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> chars.count &#123;</span><br><span class="line">        <span class="keyword">if</span> i <span class="operator">==</span> chars.count <span class="operator">-</span> <span class="number">1</span> <span class="operator">||</span> chars[i <span class="operator">+</span> <span class="number">1</span>] <span class="operator">==</span> <span class="string">&quot; &quot;</span> &#123;</span><br><span class="line">            reverse(<span class="operator">&amp;</span>chars, start, i)</span><br><span class="line">            start <span class="operator">=</span> i <span class="operator">+</span> <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(chars)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 反转一个字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">reverse</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">chars</span>: <span class="keyword">inout</span> [<span class="type">T</span>], <span class="keyword">_</span> <span class="params">start</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">end</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> start <span class="operator">=</span> start</span><br><span class="line">    <span class="keyword">var</span> end <span class="operator">=</span> end</span><br><span class="line">    <span class="keyword">while</span> start <span class="operator">&lt;</span> end &#123;</span><br><span class="line">        <span class="built_in">swap</span>(<span class="operator">&amp;</span>chars, start, end)</span><br><span class="line">        start <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        end <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 交换两个位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">swap</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">chars</span>: <span class="keyword">inout</span> [<span class="type">T</span>], <span class="keyword">_</span> <span class="params">p</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">q</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    (chars[p], chars[q]) <span class="operator">=</span> (chars[q], chars[p])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;e&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;t&quot;</span>]</span><br><span class="line"><span class="type">Optional</span>(<span class="string">&quot;blue      is     sky the&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="链表"><a class="markdownIt-Anchor" href="#链表">#</a> 链表</h2>
<h3 id="链表的基本概念"><a class="markdownIt-Anchor" href="#链表的基本概念">#</a> 链表的基本概念</h3>
<p>这里不再赘述链表基本概念，直接实现链表结点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 链表节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> val: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> next: <span class="type">ListNode</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">val</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.val <span class="operator">=</span> val</span><br><span class="line">        <span class="keyword">self</span>.next <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 通过节点，实现链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> head: <span class="type">ListNode</span>?</span><br><span class="line">    <span class="keyword">var</span> tail: <span class="type">ListNode</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尾插发</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">appendToTail</span>(<span class="keyword">_</span> <span class="params">val</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> tail <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            tail <span class="operator">=</span> <span class="type">ListNode</span>(val)</span><br><span class="line">            head <span class="operator">=</span> tail</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail<span class="operator">?</span>.next <span class="operator">=</span> <span class="type">ListNode</span>(val)</span><br><span class="line">            tail <span class="operator">=</span> tail<span class="operator">?</span>.next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">appendToHead</span>(<span class="keyword">_</span> <span class="params">val</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> head <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            head <span class="operator">=</span> <span class="type">ListNode</span>(val)</span><br><span class="line">            tail <span class="operator">=</span> head</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> temp <span class="operator">=</span> <span class="type">ListNode</span>(val)</span><br><span class="line">            temp.next <span class="operator">=</span> head</span><br><span class="line">            head <span class="operator">=</span> temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dummy-节点和尾插发"><a class="markdownIt-Anchor" href="#dummy-节点和尾插发">#</a> Dummy 节点和尾插发</h3>
<p>给出一个链表和一个值 x，要求将链表中所有小于 x 的值放左边，所有大于 x 的放右边，并且原始链表的节点顺序不变。</p>
<ul>
<li>Dummy 节点作用：它的作用就是作为一个虚拟的头结点。因为我们不知道要返回的新链表的节点是哪一个，甚至不知道是否存在。因为 Dummy 节点可以巧妙涵盖各种情况。可以用 dummy.next 方便的返回最终需要的头节点。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">partition</span>(<span class="keyword">_</span> <span class="params">head</span>: <span class="type">ListNode</span>?, <span class="keyword">_</span> <span class="params">x</span>: <span class="type">Int</span>) -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">    <span class="comment">// 引入 Dummy 节点</span></span><br><span class="line">    <span class="keyword">let</span> prevDummy <span class="operator">=</span> <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> postDummy <span class="operator">=</span> <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> prev <span class="operator">=</span> prevDummy, post <span class="operator">=</span> postDummy</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> node <span class="operator">=</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 采用尾插发处理左边和右边</span></span><br><span class="line">    <span class="keyword">while</span> node <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node<span class="operator">!</span>.val <span class="operator">&lt;</span> x &#123;</span><br><span class="line">            prev.next <span class="operator">=</span> node</span><br><span class="line">            prev <span class="operator">=</span> node<span class="operator">!</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            post.next <span class="operator">=</span> node<span class="operator">!</span></span><br><span class="line">            post <span class="operator">=</span> node<span class="operator">!</span></span><br><span class="line">        &#125;</span><br><span class="line">        node <span class="operator">=</span> node<span class="operator">!</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 防止构成换</span></span><br><span class="line">    post.next <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 左右拼接</span></span><br><span class="line">    prev.next <span class="operator">=</span> postDummy.next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prevDummy.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快行指针"><a class="markdownIt-Anchor" href="#快行指针">#</a> 快行指针</h3>
<p>快行指针用来检测链表是否有环。可以简单理解为：两个指针同时访问链表，但是移动速度不一样，如果存在环，跑的快的总有机会再次遇到跑的慢的。如果跑的快的到头了，还没见到跑的慢的，则不存在环，就好像操场跑步一样。代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">hadCycle</span>(<span class="keyword">_</span> <span class="params">head</span>: <span class="type">ListNode</span>?) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> slow <span class="operator">=</span> head</span><br><span class="line">    <span class="keyword">var</span> faster <span class="operator">=</span> head</span><br><span class="line">    <span class="keyword">while</span> faster <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">&amp;&amp;</span> faster<span class="operator">?</span>.next <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">        slow <span class="operator">=</span> slow<span class="operator">?</span>.next</span><br><span class="line">        faster <span class="operator">=</span> faster<span class="operator">?</span>.next<span class="operator">?</span>.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> slow <span class="operator">===</span> faster &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里用了三个等号。表示恒等。</p>
</blockquote>
<p>下面使用快行指针解决一个问题：</p>
<p>删除链表中倒数第 n 个节点，例如：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5，n = 2，返回 1 -&gt; 2 -&gt; 3 -&gt; 5。给定 n 的长度小于等于链表的长度。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">head</span>: <span class="type">ListNode</span>?, <span class="keyword">_</span> <span class="params">n</span>: <span class="type">Int</span>) -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head <span class="operator">=</span> head <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> dummy <span class="operator">=</span> <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">    dummy.next <span class="operator">=</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> prev: <span class="type">ListNode</span>? <span class="operator">=</span> dummy</span><br><span class="line">    <span class="keyword">var</span> post: <span class="type">ListNode</span>? <span class="operator">=</span> dummy</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置后一个节点的初始位置</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> n &#123;</span><br><span class="line">        <span class="keyword">if</span> post <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        post <span class="operator">=</span> post<span class="operator">!</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同时移动前后节点</span></span><br><span class="line">    <span class="keyword">while</span> post <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">&amp;&amp;</span> post<span class="operator">?</span>.next <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">        prev <span class="operator">=</span> prev<span class="operator">!</span>.next</span><br><span class="line">        post <span class="operator">=</span> post<span class="operator">!</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    prev<span class="operator">!</span>.next <span class="operator">=</span> prev<span class="operator">!</span>.next<span class="operator">!</span>.next</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈和队列"><a class="markdownIt-Anchor" href="#栈和队列">#</a> 栈和队列</h2>
<h3 id="栈的基本概念"><a class="markdownIt-Anchor" href="#栈的基本概念">#</a> 栈的基本概念</h3>
<ul>
<li>栈是后进先出的结构，即 FILO，first in last out。</li>
<li>如果 iOS 项目需要添加撤销操作，栈是首选的数据结构。使用数组实现更加方便。</li>
<li>无论面试还是写 App。主要关注栈的几个基本操作：push，pop，isEmpty，peek（栈顶元素），和 size。</li>
</ul>
<p>下面定义一个栈：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="comment">/// 持有的元素类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 是否为空</span></span><br><span class="line">    <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">/// 栈的大小</span></span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">/// 栈顶元素</span></span><br><span class="line">    <span class="keyword">var</span> peek: <span class="type">Element</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///进栈</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">newElement</span>: <span class="type">Element</span>)</span><br><span class="line">    <span class="comment">/// 出栈</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Element</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IntergerStack</span>: <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> <span class="operator">=</span> <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">return</span> stacks.isEmpty &#125;</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">Int</span> &#123; <span class="keyword">return</span> stacks.count &#125;</span><br><span class="line">    <span class="keyword">var</span> peek: <span class="type">Int</span>? &#123; <span class="keyword">return</span> stacks.last &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> stacks <span class="operator">=</span> [<span class="type">Element</span>]()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">newElement</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        stacks.append(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> stacks.popLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列的基本概念"><a class="markdownIt-Anchor" href="#队列的基本概念">#</a> 队列的基本概念</h3>
<ul>
<li>队列是先进先出的结构，即 FIFO，first in first out。</li>
<li>iOS 开发中的多线程 GCD 以及 NSOperation 都是基于队列实现的。</li>
<li>关于队列只需要关注 enqueue、dequeue、isEmpty、peek 和 size 等操作。</li>
</ul>
<p>下面定义一个队列：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">/// 持有的元素类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 是否为空</span></span><br><span class="line">    <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">/// 队列的大小</span></span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">/// 队首元素</span></span><br><span class="line">    <span class="keyword">var</span> peek: <span class="type">Element</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 入队</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">newElement</span>: <span class="type">Element</span>)</span><br><span class="line">    <span class="comment">/// 出队</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">Element</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IntegerQueue</span>: <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> <span class="operator">=</span> <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">return</span> left.isEmpty <span class="operator">&amp;&amp;</span> right.isEmpty &#125;</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">Int</span> &#123; <span class="keyword">return</span> left.count <span class="operator">+</span> right.count &#125;</span><br><span class="line">    <span class="keyword">var</span> peek: <span class="type">Int</span>? &#123; <span class="keyword">return</span> left.isEmpty <span class="operator">?</span> right.first : left.last &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> left <span class="operator">=</span> [<span class="type">Element</span>]()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> right <span class="operator">=</span> [<span class="type">Element</span>]()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">newElement</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        right.append(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> left.isEmpty &#123;</span><br><span class="line">            left <span class="operator">=</span> right.reversed()</span><br><span class="line">            right.removeAll()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.popLast()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈和队列实战面试题"><a class="markdownIt-Anchor" href="#栈和队列实战面试题">#</a> 栈和队列实战面试题</h3>
<p>给出一个文件的绝对路径，要求将其简化。如：</p>
<ul>
<li>路径是 “/home/”，简化后为 “/home”。</li>
<li>路径是 “/a/./…/…/c”，简化后为 “/c”。</li>
<li></li>
</ul>
<p>根据常识，有以下规则：</p>
<ul>
<li>“.” 代表当前路径。比如 “/a/.” 实际上就是 “/a”，无论输入多少个 “.”(除了 2 个)，都返回当前目录。</li>
<li>“…” 代表上一级目录，比如 “a/b/…” 实际就是 “/a”。</li>
</ul>
<p>实现代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">simplifyPath</span>(<span class="params">path</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="comment">// 用数组来实现栈的功能</span></span><br><span class="line">    <span class="keyword">var</span> pathStack <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line">    <span class="comment">// 拆分原路径</span></span><br><span class="line">    <span class="keyword">let</span> paths <span class="operator">=</span> path.components(separatedBy: <span class="string">&quot;/&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> paths &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;path = <span class="subst">\(path)</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">guard</span> path <span class="operator">!=</span> <span class="string">&quot;.&quot;</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对 .. 使用 pop 操作</span></span><br><span class="line">        <span class="keyword">if</span> path <span class="operator">==</span> <span class="string">&quot;..&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> pathStack.count <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">                pathStack.removeLast()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 数组为空，上来就是 .. 则不操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> path <span class="operator">!=</span> <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            pathStack.append(path)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 空路径，不用处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;stacks = <span class="subst">\(pathStack)</span>&quot;</span>)</span><br><span class="line">    <span class="comment">/// 将栈中的内容转化为优化后的新路径</span></span><br><span class="line">    <span class="keyword">let</span> res <span class="operator">=</span> pathStack.reduce(<span class="string">&quot;&quot;</span>) &#123; totol, dir <span class="keyword">in</span></span><br><span class="line">        <span class="string">&quot;<span class="subst">\(totol)</span>/<span class="subst">\(dir)</span>&quot;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意空路径的结果是 /</span></span><br><span class="line">    <span class="keyword">return</span> res.isEmpty <span class="operator">?</span> <span class="string">&quot;/&quot;</span> : res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树">#</a> 二叉树</h2>
]]></content>
      <categories>
        <category>iOS开发</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>隐私协议</title>
    <url>/2022/09/08/%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/</url>
    <content><![CDATA[<h3 id="本应用隐私保护协议"><a class="markdownIt-Anchor" href="#本应用隐私保护协议">#</a> 本应用隐私保护协议</h3>
<p>本应用尊重并保护所有使用本应用网络服务的个人的隐私。本隐私权政策（以下称 &quot;隐私权政策&quot;）规定，未事先得到您的同意，我们不会有意将涉及您个人隐私的内容透露给任何第三方，但本政策另有说明的除外。</p>
<span id="more"></span>
<h4 id="1-我们需要哪些访问权限"><a class="markdownIt-Anchor" href="#1-我们需要哪些访问权限">#</a> 1. 我们需要哪些访问权限</h4>
<p>(1) 访问网络权限<br>
 (2) 访问相册权限</p>
<h4 id="2-为什么我们需要这些访问权限"><a class="markdownIt-Anchor" href="#2-为什么我们需要这些访问权限">#</a> 2. 为什么我们需要这些访问权限</h4>
<p>(1) 访问网络权限 - 我们提供在线画报，需要从网络上获取画报列表和图片，所以需要访问网络权限<br>
 (2) 访问相册权限 - 我们提供保存图片到相册功能，所以需要访问相册权限</p>
<h4 id="3-本应用和ip设备等信息"><a class="markdownIt-Anchor" href="#3-本应用和ip设备等信息">#</a> 3. 本应用和 IP，设备等信息</h4>
<p>在您首次访问本应用后，本应用会对服务器发送网络请求。请求中会携带您设备的 IP，IP 地址是指互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），是 IP Address 的缩写。 IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。用于标识不同的访问用户。本应用使用 cookie 来提高我们的服务质量并更多地了解用户群体。IP 所承载您的个人信息均视为您个人隐私，本应用将依照用户隐私政策进行保护。</p>
<h4 id="4-我们收集哪些信息"><a class="markdownIt-Anchor" href="#4-我们收集哪些信息">#</a> 4. 我们收集哪些信息？</h4>
<p>(1) 我们可能会搜集使用脸部轮廓信息。 用户在使用人像抠图，人物动漫化，人物变老，男变女，女变男，人物动漫化功能时，上传的图片中如果包含人脸信息，我们会在处理过程中使用这些人脸的脸部轮廓信息，用于人工智能算法的处理。我们不存储，不共享这些脸部轮廓信息。处理完成后的图片，因为需要提供下载结果服务，会在服务器存储 24 小时，24 小时候会定时清除。<br>
(2) 本应用不收集有关您的任何特定信息，除非您特意提供了此类信息或者您已经同意我们收集此类信息。本应用所记录和保存的信息包括：时间、手机设备类型、应用语言和用户 IP 地址等。这些信息用于核实我们的记录并向用户提供更适合需要的服务。</p>
<h4 id="5-本应用隐私政策的具体内容"><a class="markdownIt-Anchor" href="#5-本应用隐私政策的具体内容">#</a> 5. 本应用隐私政策的具体内容</h4>
<p>保护用户隐私是本应用的一项基本政策，本应用保证不对外公开或向第三方提供您的申请资料及您在使用网络服务时存储在本应用的个人信息，但下列情况除外：</p>
<p>(a) 事先获得用户的明确授权；<br>
(b) 根据有关的法律法规要求；<br>
© 按照相关政府主管部门的要求；<br>
(d) 为维护社会公众的利益；<br>
(e) 为维护本应用的合法权益。</p>
<p>本应用可能会与第三方合作向您提供相关的网络服务，在此情况下，如该第三方同意承担与本应用同等的保护用户隐私的责任，则本应用可将您的个人信息等提供给该第三方。在不透露您隐私资料的前提下，本应用有权对整个用户数据库进行分析并对用户数据库进行商业上的利用（包括但不限于公布、分析或以其它方式使用用户访问量、访问时段、用户偏好等用户数据信息）。</p>
<h4 id="6-对隐私权政策的认同和修订"><a class="markdownIt-Anchor" href="#6-对隐私权政策的认同和修订">#</a> 6. 对隐私权政策的认同和修订</h4>
<p>您在使用本应用网络服务，即表示您同意我们收集并使用您的资料（如本政策所述），并表示您认同我们的网络服务使用协议。本应用保留修改此隐私权政策的权力。如果您不同意本应用修改的内容，您可以主动退出应用，不使用本应用提供的服务。如果您在修改内容公告后 15 天内未主动取消服务，则视为接受本政策的变更；修改内容公告后您如果仍继续使用本应用提供的产品和服务亦构成对本政策变更的接受。</p>
]]></content>
      <categories>
        <category>政策</category>
      </categories>
      <tags>
        <tag>隐私政策</tag>
        <tag>用户隐私</tag>
      </tags>
  </entry>
</search>
